# TASK-07B P0/P1修复实施报告

> **实施时间**: 2025-11-08  
> **状态**: ✅ **P0/P1修复已完成**

---

## 1. 修复概览

根据用户提供的"五维体检与修复建议"，按照优先级P0→P1→P2实施修复，重点聚焦：一致性、兼容性、业务流正确性与参数口径统一。

---

## 2. P0必改项（已全部完成）

### 2.1 P0-1: 统一SQLite表结构+主键口径 ✅

**问题**: 
- 老版仅9列（无signal_type/guard_reason/run_id等扩展字段）
- 新版虽已扩展到含signal_type/guard_reason，但仍缺少run_id，且主键是(ts_ms, symbol)（会在回放/短跑反复运行时产生主键冲突）

**修复**:
- ✅ 统一到12+列并引入run_id，把主键改为`(run_id, ts_ms, symbol)`
- ✅ 允许同一毫秒多次回放/多次测试而不互相覆盖
- ✅ 实现自动迁移逻辑（`_migrate_schema_if_needed()`）

**代码位置**:
- `src/alpha_core/signals/core_algo.py::SqliteSink.__init__()` (行210-237)
- `src/alpha_core/signals/core_algo.py::SqliteSink._migrate_schema_if_needed()` (行265-378)

**表结构**:
```sql
CREATE TABLE IF NOT EXISTS signals (
    ts_ms INTEGER NOT NULL,
    symbol TEXT NOT NULL,
    score REAL,
    z_ofi REAL,
    z_cvd REAL,
    regime TEXT,
    div_type TEXT,
    signal_type TEXT,
    confirm INTEGER,
    gating INTEGER,
    guard_reason TEXT,
    run_id TEXT NOT NULL,
    created_at TEXT DEFAULT (DATETIME('now')),
    PRIMARY KEY (run_id, ts_ms, symbol)
);
```

### 2.2 P0-2: 统一Sink选择口径 ✅

**问题**: 
- 仓库中存在两套不同入口：一套通过V13_SINK环境变量决定sink（env驱动），一套通过config.sink/sink_kind决定（配置驱动）

**修复**:
- ✅ 统一优先级：CLI/构造参数 > 配置 > 环境 > 默认
- ✅ 在CoreAlgorithm启动时明确打印最终生效值

**代码位置**:
- `src/alpha_core/signals/core_algo.py::CoreAlgorithm.__init__()` (行574-582)

**优先级逻辑**:
```python
final_sink_kind = sink_kind or sink_cfg.get("kind") or os.getenv("V13_SINK") or "jsonl"
logger.info(f"[CoreAlgorithm] Sink选择: sink_kind={sink_kind}, config.kind={sink_cfg.get('kind')}, V13_SINK={os.getenv('V13_SINK')}, 最终生效={final_sink_kind}")
```

### 2.3 P0-3: 固定MultiSink顺序与数据一致性 ✅

**问题**: 
- MultiSink目前会把同一个entry依次传给子sink（同一dict引用），可能导致子sink修改字段

**修复**:
- ✅ 在MultiSink.emit()里对entry做浅拷贝再下发
- ✅ 确保所有子sink都只读entry，不要修改字段

**代码位置**:
- `src/alpha_core/signals/core_algo.py::MultiSink.emit()` (行524-528)

**实现**:
```python
def emit(self, entry: Dict[str, Any]) -> None:
    # P0: 固定MultiSink顺序与数据一致性（浅拷贝entry，避免子sink修改影响）
    entry_copy = entry.copy()
    for sink in self.sinks:
        sink.emit(entry_copy)
```

### 2.4 P0-4: Reporter的对账与run_id过滤 ✅

**问题**: 
- 如果DB端没有run_id列，SQLite侧就无法按run_id过滤，自然会出现数量对不齐

**修复**:
- ✅ 确认JSONL端只统计`confirm==true`的行；SQLite端`WHERE confirm=1`统计口径一致
- ✅ Reporter的`_analyze_jsonl()`和`_analyze_sqlite()`都已支持run_id过滤

**代码位置**:
- `orchestrator/run.py::Reporter._analyze_jsonl()` (行786-788)
- `orchestrator/run.py::Reporter._analyze_sqlite()` (行933-938)

**确认**: confirm/strong的生成逻辑在CoreAlgorithm端是一致的（先选方向→闸门→确认→买卖/强弱），并不会天然产生两端不一致。

---

## 3. P1建议项（已全部完成）

### 3.1 P1-1: executemany批量提交的异常与补偿 ✅

**问题**: 
- 部分实现没有围绕executemany做任何异常保护（任何一条主键冲突都可能整批失败并中断线程）

**修复**:
- ✅ 将INSERT改为`INSERT OR IGNORE`（避免主键冲突导致整批失败）
- ✅ 包裹try/except，重试3次带退避
- ✅ 仍失败时将buf逐条写入`runtime/failed_batches.jsonl`做补偿
- ✅ 在close()里兜底flush + WAL checkpoint

**代码位置**:
- `src/alpha_core/signals/core_algo.py::SqliteSink._flush_batch()` (行413-475)
- `src/alpha_core/signals/core_algo.py::SqliteSink.close()` (行477-512)

**实现**:
```python
try:
    self.conn.executemany(
        "INSERT OR IGNORE INTO signals (...) VALUES (...);",
        self._batch_queue,
    )
    self.conn.commit()
except (sqlite3.IntegrityError, sqlite3.OperationalError, Exception) as e:
    # 重试3次带退避
    # 仍失败则写入补偿文件
```

### 3.2 P1-2: 烟雾测试参数（短跑一刀切） ✅

**问题**: 
- 需要固定短跑/回放参数

**修复**:
- ✅ 短跑/回放建议固定：`SQLITE_BATCH_N=1`，`SQLITE_FLUSH_MS=10`
- ✅ 保留JSONL的按条fsync与后台线程定期fsync/rotate

**代码位置**:
- `scripts/run_task07b_smoke_3min.py` (已设置)

### 3.3 P1-3: "sink_used"抓取鲁棒性 ✅

**问题**: 
- [CoreAlgorithm] sink_used=...已打印，但Reporter可能只扫了stdout路径

**修复**:
- ✅ 同时解析signal的stdout/stderr
- ✅ 在run_manifest中记录sink_used，便于CI对账可追溯

**代码位置**:
- `orchestrator/run.py::main_async()` (行2111-2141)

**实现**:
```python
log_files = []
if signal_state.stdout_log and signal_state.stdout_log.exists():
    log_files.append(signal_state.stdout_log)
if signal_state.stderr_log and signal_state.stderr_log.exists():
    log_files.append(signal_state.stderr_log)

for log_file in log_files:
    # 解析sink_used
```

### 3.4 P1-4: 对账"找差"工具 ✅

**问题**: 
- 需要定位confirm差异0.2%阈值外样本

**修复**:
- ✅ 创建`scripts/find_parity_diff.py`脚本
- ✅ 使用`(run_id, ts_ms, symbol, signal_type, confirm)`作为"对账键"
- ✅ 输出具体缺失/不一致行，便于精准复盘

**代码位置**:
- `scripts/find_parity_diff.py` (新建)

**功能**:
- 加载JSONL和SQLite的对账键集合
- 找出差异样本（JSONL独有、SQLite独有）
- 按confirm分组统计
- 输出前100条样本

---

## 4. 验收标准检查

### 4.1 DoD验收清单

- ✅ SQLite signals表存在run_id且`PRIMARY KEY(run_id, ts_ms, symbol)`
- ✅ INSERT使用`OR IGNORE`，批量提交有重试+补偿
- ✅ sink_used在日志中出现，Reporter能正确写入run_manifest
- ⚠️ 烟雾3分钟：JSONL_count(run_id) ≈ SQLite_count(run_id)，偏差 < 0.2%（需验证）
- ⚠️ verify_sink_parity.py返回0（需验证）
- ✅ 单一SqliteSink/JsonlSink实现对外可见（无重复版本）

### 4.2 测试结果

**最新测试**（2025-11-08 22:15:28）:
- ✅ Orchestrator运行成功（退出码0）
- ✅ 补偿文件检查通过（无补偿文件）
- ⚠️ 等价性测试失败（UnicodeDecodeError，可能是编码问题）

**需要验证**:
1. 运行完整3分钟测试，验证数据一致性
2. 使用`find_parity_diff.py`定位差异样本
3. 验证sink_used提取是否成功

---

## 5. 代码变更统计

### 5.1 修改的文件

1. **src/alpha_core/signals/core_algo.py**
   - `SqliteSink.__init__()`: 统一表结构（(run_id, ts_ms, symbol)主键）
   - `SqliteSink._migrate_schema_if_needed()`: 实现自动迁移逻辑
   - `SqliteSink._flush_batch()`: INSERT OR IGNORE + 重试+补偿
   - `MultiSink.emit()`: 浅拷贝entry
   - `CoreAlgorithm.__init__()`: 统一Sink选择口径

2. **orchestrator/run.py**
   - `main_async()`: sink_used提取鲁棒性（同时解析stdout/stderr）

3. **scripts/find_parity_diff.py** (新建)
   - 对账找差工具

### 5.2 关键变更

- **表结构**: `id AUTOINCREMENT` → `PRIMARY KEY (run_id, ts_ms, symbol)`
- **INSERT**: `INSERT` → `INSERT OR IGNORE`
- **MultiSink**: 直接传递entry → 浅拷贝entry
- **Sink选择**: 多套逻辑 → 统一优先级
- **sink_used提取**: 仅stdout → stdout+stderr

---

## 6. 下一步

1. **验证修复效果**: 运行完整3分钟测试，验证数据一致性
2. **使用找差工具**: 使用`find_parity_diff.py`定位差异样本
3. **P2工程化**: 消除多版本漂移、参数优先级&自检首屏

---

**报告生成时间**: 2025-11-08  
**最后更新**: 2025-11-08  
**实施者**: Cursor AI Assistant

