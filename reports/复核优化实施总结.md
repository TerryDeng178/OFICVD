# 复核优化实施总结

> **实施日期**: 2025-11-07  
> **优化版本**: v4.0.3  
> **基于**: 复核结论与可直接落地的优化清单

---

## 执行摘要

本次优化基于复核结论，实施了 6 项优化（P0 必做 3 项 + P1 建议 3 项），进一步提升了系统的健壮性、可观测性和可追溯性。

### 优化成果

| 优先级 | 优化项 | 状态 | 影响 |
|--------|--------|------|------|
| **P0** | SQLite 就绪探针 schema 检测 | ✅ 完成 | 避免空库"假就绪" |
| **P0** | Reporter 告警细分 | ✅ 完成 | 定位更快（NO_INPUT_FILES vs ALL_GATED） |
| **P0** | Broker 参数外露抽样率 | ✅ 完成 | 便于 SMOKE/回放控制订单节律 |
| **P1** | 双 Sink 结果对齐自动回归 | ✅ 完成 | 统计口径一致性自动化验证 |
| **P1** | run_manifest 增补版本/指纹 | ✅ 完成 | 便于跨环境复现 |
| **P1** | 分钟键更友好 | ✅ 完成 | 人类可读时间展示 |

---

## P0 必做项实施

### P0: SQLite 就绪探针增加 schema 检测

**实施内容**:

**文件**: `orchestrator/run.py`

**改动**:
- 在 `_check_ready()` 的 `sqlite_connect` 分支中，成功连接后验证 `signals` 表是否存在
- 无表则返回 `False`，避免空库"假就绪"

**代码位置**:
```python
elif spec.ready_probe == "sqlite_connect":
    db_path = spec.ready_probe_args.get("db_path", "")
    if db_path:
        db_full_path = self.project_root / db_path
        if db_full_path.exists():
            try:
                conn = sqlite3.connect(str(db_full_path), timeout=1.0)
                # P0: SQLite 就绪探针增加 schema 检测
                cursor = conn.cursor()
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='signals'")
                if not cursor.fetchone():
                    conn.close()
                    return False
                conn.close()
                return True
            except Exception:
                pass
    return False
```

**效果**:
- ✅ 避免空库被误判为就绪
- ✅ 确保数据库已初始化

---

### P0: Reporter 告警细分（定位更快）

**实施内容**:

**文件**: `orchestrator/run.py`

**改动**:
- 在 `_analyze_jsonl()` 和 `_analyze_sqlite()` 中细分告警
- `NO_INPUT_FILES`: 找不到任何输入文件
- `ALL_GATED`: 有输入但所有信号都被护栏拦截（confirm=0）

**代码位置**:
```python
# P0: Reporter 告警细分（定位更快）
if report["total"] == 0:
    if not jsonl_files:  # sqlite 分支：if total_signals == 0
        report["warnings"].append("NO_INPUT_FILES")
    elif total_signals > 0:
        report["warnings"].append("ALL_GATED")
    else:
        report["warnings"].append("QUIET_RUN")
```

**效果**:
- ✅ 快速区分"无输入"和"全部被拦截"
- ✅ 便于问题定位和排查

---

### P0: Broker 参数外露抽样率

**实施内容**:

**文件**: `orchestrator/run.py`, `mcp/broker_gateway_server/app.py`

**改动**:
1. **Orchestrator**: 从环境变量读取 `BROKER_SAMPLE_RATE`（默认 0.2）
2. **Broker Gateway**: 新增 `--sample_rate` 参数，支持可配置抽样率

**代码位置**:
```python
# orchestrator/run.py
broker_sample_rate = os.getenv("BROKER_SAMPLE_RATE", "0.2")
broker_spec = ProcessSpec(
    name="broker",
    cmd=[..., "--sample_rate", broker_sample_rate],
    ...
)

# mcp/broker_gateway_server/app.py
parser.add_argument(
    "--sample_rate",
    type=float,
    default=0.2,
    help="普通信号抽样率（默认: 0.2，即 1/5 概率下单）"
)

class MockBroker:
    def __init__(self, output_file: Path, sample_rate: float = 0.2):
        self.sample_rate = sample_rate
        ...
    
    def process_signal(self, signal: Dict):
        ...
        # 普通信号：按 sample_rate 概率下单
        should_order = (random.random() < self.sample_rate)
```

**使用方式**:
```powershell
# 使用默认抽样率（0.2）
python -m orchestrator.run --config ./config/defaults.smoke.yaml --enable broker

# 自定义抽样率
$env:BROKER_SAMPLE_RATE = "0.5"
python -m orchestrator.run --config ./config/defaults.smoke.yaml --enable broker
```

**效果**:
- ✅ 便于 SMOKE/回放控制订单节律
- ✅ 支持可配置抽样率

---

## P1 建议项实施

### P1: 双 Sink 结果对齐自动回归

**实施内容**:

**文件**: `scripts/verify_sink_parity.sh`, `scripts/verify_sink_parity.ps1`

**功能**:
- 同一窗口分别运行 JSONL/SQLite 两轮
- 对比统计结果（total, buy_count, sell_count, strong_ratio 等）
- 容忍 ≤10% 差异

**使用方式**:
```powershell
# PowerShell
.\scripts\verify_sink_parity.ps1 -Config ./config/defaults.smoke.yaml -Minutes 2

# Bash
chmod +x scripts/verify_sink_parity.sh
./scripts/verify_sink_parity.sh ./config/defaults.smoke.yaml 2
```

**验证指标**:
- ✅ total（总信号数）
- ✅ buy_count（买入信号）
- ✅ sell_count（卖出信号）
- ✅ strong_buy_count（强买入）
- ✅ strong_sell_count（强卖出）
- ✅ strong_ratio（强信号比例）

**效果**:
- ✅ 统计口径一致性自动化验证
- ✅ 便于发现统计差异

---

### P1: run_manifest 增补版本/指纹

**实施内容**:

**文件**: `orchestrator/run.py`

**改动**:
- 在 `run_manifest` 中新增 `source_versions` 字段
- 包含 `git_head`（Git HEAD commit）、`git_dirty`（是否有未提交更改）、`python_version`（Python 版本）

**代码位置**:
```python
# P1: run_manifest 增补"版本/指纹"
git_head = None
git_dirty = False
try:
    import subprocess
    git_head = subprocess.check_output(
        ["git", "rev-parse", "HEAD"],
        cwd=project_root,
        stderr=subprocess.DEVNULL
    ).decode("utf-8").strip()
    git_status = subprocess.check_output(
        ["git", "status", "--porcelain"],
        cwd=project_root,
        stderr=subprocess.DEVNULL
    ).decode("utf-8").strip()
    git_dirty = bool(git_status)
except Exception:
    pass

manifest = {
    ...
    "source_versions": {
        "git_head": git_head,
        "git_dirty": git_dirty,
        "python_version": sys.version.split()[0]
    }
}
```

**效果**:
- ✅ 便于跨环境复现
- ✅ 追踪代码版本和依赖

---

### P1: 分钟键更友好（人类可读）

**实施内容**:

**文件**: `orchestrator/run.py`

**改动**:
1. **JSON 输出**: `per_minute` 中新增 `minute_human` 字段（人类可读时间）
2. **Markdown 输出**: 表格中同时显示人类可读时间和分钟键

**代码位置**:
```python
# JSON 输出
report["per_minute"].append({
    "minute": minute_key,
    "minute_human": human_readable,  # P1: 人类可读时间
    "count": count
})

# Markdown 输出
fp.write(f"| 分钟（人类可读） | 分钟键 | 信号数 |\n")
fp.write(f"|---------------|--------|--------|\n")
for item in report['per_minute']:
    minute_key = item['minute']
    human_readable = dt.strftime("%Y-%m-%d %H:%M")
    fp.write(f"| {human_readable} | {minute_key} | {item['count']} |\n")
```

**效果**:
- ✅ 人类可读时间展示（如：2025-11-07 13:55）
- ✅ 保留原分钟键作为隐藏字段或 JSON 输出两列
- ✅ 提升可读性

---

## 文件变更清单

| 文件 | 变更类型 | 说明 |
|------|---------|------|
| `orchestrator/run.py` | 修改 | P0 三项 + P1 三项 |
| `mcp/broker_gateway_server/app.py` | 修改 | P0: Broker 抽样率参数 |
| `scripts/verify_sink_parity.sh` | 新增 | P1: 双 Sink 结果对齐脚本（Bash） |
| `scripts/verify_sink_parity.ps1` | 新增 | P1: 双 Sink 结果对齐脚本（PowerShell） |

---

## 验证清单

### P0 项验证

- [x] **SQLite 就绪探针**: ✅ 验证 signals 表存在
- [x] **Reporter 告警细分**: ✅ 区分 NO_INPUT_FILES 与 ALL_GATED
- [x] **Broker 抽样率**: ✅ 支持 --sample_rate 且默认 0.2

### P1 项验证

- [x] **双 Sink 结果对齐**: ✅ 脚本已创建，待手动测试
- [x] **run_manifest 版本/指纹**: ✅ 包含 git_head/dirty/python_version
- [x] **分钟键更友好**: ✅ JSON 和 Markdown 都包含人类可读时间

---

## 测试建议

### 快速验证

```powershell
# 1. 验证 SQLite 就绪探针
# 创建空数据库，应返回未就绪

# 2. 验证 Reporter 告警细分
python -m orchestrator.run `
  --config ./config/defaults.smoke.yaml `
  --enable signal,report `
  --sink jsonl `
  --minutes 1

# 检查报表 warnings 是否包含 NO_INPUT_FILES 或 ALL_GATED

# 3. 验证 Broker 抽样率
$env:BROKER_SAMPLE_RATE = "0.5"
python -m orchestrator.run `
  --config ./config/defaults.smoke.yaml `
  --enable broker `
  --minutes 1

# 4. 验证双 Sink 结果对齐
.\scripts\verify_sink_parity.ps1 -Config ./config/defaults.smoke.yaml -Minutes 2

# 5. 验证 run_manifest 版本/指纹
# 检查 run_manifest_*.json 是否包含 source_versions 字段

# 6. 验证分钟键更友好
# 检查报表 Markdown 是否包含人类可读时间
```

---

## 配置建议

### SMOKE 基线

- `consistency_min=0.08`（已验证"更易判读其它护栏"）
- 生产基线继续用 `consistency_min_per_regime={active:0.10, quiet:0.15}`

### 输入模式

- 默认 `V13_INPUT_MODE=preview`
- 必要时通过 `V13_INPUT_DIR` 指定回放窗口根目录

### 健康探针（历史场景）

- 在 SMOKE/回放配置里把 JSONL 探针的 `min_new_last_seconds: 0` 打开
- 实时场景维持当前 120s/60s 的窗口要求

---

**优化完成时间**: 2025-11-07  
**优化状态**: ✅ P0 全部完成，P1 全部完成  
**测试状态**: ⏳ 待验证

