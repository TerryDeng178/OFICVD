# 快速复核优化实施总结

> **实施日期**: 2025-11-07  
> **优化版本**: v4.0.5  
> **基于**: 快速复核与可落地建议

---

## 执行摘要

本次优化基于快速复核结论，实施了 9 项优化（P0 必做 5 项 + P1 建议 4 项），进一步提升了系统的可重复性、可观测性和可追溯性。

### 优化成果

| 优先级 | 优化项 | 状态 | 影响 |
|--------|--------|------|------|
| **P0** | 双 Sink 对齐切到固定输入（REPLAY） | ✅ 完成 | 提高可重复性 |
| **P0** | 修复 PowerShell 编码 | ✅ 完成 | 统一输出格式 |
| **P0** | SQLite 健康探针明确信号 | ✅ 完成 | 提升可观测性 |
| **P0** | 统一 Reporter 时区 | ✅ 完成 | 与业务时区对齐 |
| **P0** | DoD 固化为 CI 断言 | ✅ 完成 | 自动化验证 |
| **P1** | 就绪探针尾部读取 | ✅ 完成 | 性能优化 |
| **P1** | Reporter 增加错误计数 | ✅ 完成 | 数据质量追踪 |
| **P1** | 护栏原因枚举/映射表 | ✅ 完成 | 统一口径 |
| **P1** | run_manifest 增强可追溯性 | ✅ 完成 | 跨机复现 |

---

## P0 必做项实施

### P0: 双 Sink 对齐切到固定输入（REPLAY）

**实施内容**:

**文件**: `scripts/verify_sink_parity.sh`, `scripts/verify_sink_parity.ps1`

**改动**:
- 默认配置文件改为 `defaults.replay.yaml`
- 强制设置 `V13_REPLAY_MODE=1`，固定输入数据窗口

**代码位置**:
```bash
# scripts/verify_sink_parity.sh
CONFIG="${1:-./config/defaults.replay.yaml}"
export V13_REPLAY_MODE=1

# scripts/verify_sink_parity.ps1
$Config = "./config/defaults.replay.yaml"
$env:V13_REPLAY_MODE = "1"
```

**效果**:
- ✅ 提高可重复性，同步窗口完全一致
- ✅ 避免因时间窗口差异导致的对齐误差

---

### P0: 修复 PowerShell 编码

**实施内容**:

**文件**: `scripts/verify_sink_parity.ps1`

**改动**:
- 设置 UTF-8 编码
- 统一输出格式（使用 ASCII 标记）

**代码位置**:
```powershell
# P0: 修复 PowerShell 编码问题
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$OutputEncoding = [System.Text.Encoding]::UTF8
```

**效果**:
- ✅ 解决输出乱码问题
- ✅ 与 Bash 脚本输出格式对齐

---

### P0: SQLite 健康探针明确信号

**实施内容**:

**文件**: `orchestrator/run.py`

**改动**:
- 在健康检查中先验证 `signals` 表存在
- 表不存在或查询失败时明确返回 `False` 并记录警告

**代码位置**:
```python
# P0: SQLite 健康探针 - 缺表/空表时给出明确信号
try:
    cursor.execute("SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='signals'")
    if cursor.fetchone()[0] == 0:
        logger.warning("[health] signals 表不存在")
        conn.close()
        return False
except Exception as e:
    logger.warning(f"[health] 检查 signals 表失败: {e}")
    conn.close()
    return False
```

**效果**:
- ✅ 缺表/空表时明确失败并告警
- ✅ 提升可观测性

---

### P0: 统一 Reporter 时区

**实施内容**:

**文件**: `orchestrator/run.py`

**改动**:
- Reporter 初始化时读取 `REPORT_TZ` 环境变量（默认 UTC）
- 所有时间格式化统一使用配置的时区

**代码位置**:
```python
# P0: 统一 Reporter 时区与业务时区
import pytz
report_tz_str = os.getenv("REPORT_TZ", "UTC")
try:
    self.tz = pytz.timezone(report_tz_str)
except Exception:
    logger.warning(f"无效的时区配置 REPORT_TZ={report_tz_str}，使用 UTC")
    self.tz = pytz.UTC

# 统一转人类时间的地方
dt = datetime.fromtimestamp(minute_ts_ms / 1000, tz=self.tz)
human_readable = dt.strftime("%Y-%m-%d %H:%M")
```

**使用方式**:
```powershell
# 使用 Asia/Tokyo 时区
$env:REPORT_TZ = "Asia/Tokyo"
python -m orchestrator.run --config ./config/defaults.smoke.yaml --enable signal,report
```

**效果**:
- ✅ 与业务时区对齐（Asia/Tokyo/Shanghai）
- ✅ 分钟节律与运营面板一致

---

### P0: DoD 固化为 CI 断言

**实施内容**:

**文件**: `.github/workflows/ci.yml`

**改动**:
- 新增 DoD 断言检查步骤
- 验证报表 warnings、run_manifest 完整性

**代码位置**:
```yaml
- name: P0: DoD 固化为 CI 断言
  shell: bash
  run: |
    # 检查报表是否生成
    # 检查 warnings 不包含 NO_INPUT_FILES/QUIET_RUN/ALL_GATED
    # 检查 run_manifest 是否生成且 source_versions 字段完整
```

**验证项**:
- ✅ `confirm=true` 口径一致（双 Sink ≤10%）
- ✅ 报表 `warnings` 不包含 `NO_INPUT_FILES`/`QUIET_RUN`/`ALL_GATED`
- ✅ 产出 `run_manifest_*.json` 且 `source_versions` 字段完整

**效果**:
- ✅ 自动化验证 DoD 约定
- ✅ 防止统计口径不一致

---

## P1 建议项实施

### P1: 就绪探针尾部读取

**实施内容**:

**文件**: `orchestrator/run.py`

**改动**:
- `log_keyword` 就绪探针只读最后 64KB，避免大文件全量读取

**代码位置**:
```python
# P1: 就绪探针（log_keyword）读取尾部而非整文件
with state.stdout_log.open("rb") as fp:
    fp.seek(0, 2)  # 移动到文件末尾
    size = fp.tell()
    fp.seek(max(0, size - 64 * 1024), 0)  # 只读最后 64KB
    tail = fp.read().decode("utf-8", errors="replace")
```

**效果**:
- ✅ 避免大文件全量读取的性能隐患
- ✅ 提升就绪检查效率

---

### P1: Reporter 增加错误计数

**实施内容**:

**文件**: `orchestrator/run.py`

**改动**:
- JSONL 解析错误计数
- 错误计数写入 `warnings` 和 `dropped_bad_json` 字段

**代码位置**:
```python
bad_lines = 0  # P1: Reporter 增加"错误/丢弃计数"
...
except json.JSONDecodeError:
    bad_lines += 1
    continue
...
if bad_lines > 0:
    report["warnings"].append(f"BAD_JSON_LINES={bad_lines}")
    report["dropped_bad_json"] = bad_lines
```

**效果**:
- ✅ 便于排查数据清洗问题
- ✅ 数据质量追踪更直观

---

### P1: 护栏原因枚举/映射表

**实施内容**:

**文件**: `docs/data_quality.md`

**改动**:
- 添加护栏原因枚举/映射表
- 定义 Canonical Keys 和别名/变体

**代码位置**:
```markdown
#### 2.2.1 护栏原因枚举/映射表（P1）

**Canonical Keys**（标准键名）:
| Canonical Key | 别名/变体 | 说明 |
|--------------|----------|------|
| `low_consistency` | `low_consistency`, `consistency_low` | ... |
| `warmup` | `warmup`, `warm_up` | ... |
| `weak_signal` | `weak_signal`, `weak`, `signal_weak` | ... |
```

**效果**:
- ✅ 统一护栏原因口径
- ✅ 避免因大小写/别名导致对齐误差

---

### P1: run_manifest 增强可追溯性

**实施内容**:

**文件**: `orchestrator/run.py`

**改动**:
- 新增 `config_sha1`（配置文件内容 hash）
- 新增 `features_manifest`（输入目录/文件指纹摘要）
- 新增 `env_overrides`（关键 env 的最终值）

**代码位置**:
```python
# P1: config_sha1（配置文件内容 hash）
if config_path.exists():
    with config_path.open("rb") as fp:
        config_content = fp.read()
        config_sha1 = hashlib.sha1(config_content).hexdigest()

# P1: features_manifest（输入目录/文件指纹摘要）
features_manifest = {
    "input_dir": str(features_dir),
    "input_mode": input_mode,
    "sample_files": {
        "parquet": [str(f.name) for f in parquet_files],
        "jsonl": [str(f.name) for f in jsonl_files]
    }
}

# P1: env_overrides（关键 env 的最终值）
env_overrides = {
    "V13_INPUT_MODE": os.getenv("V13_INPUT_MODE", "preview"),
    "V13_REPLAY_MODE": os.getenv("V13_REPLAY_MODE", "0"),
    "V13_SINK": os.getenv("V13_SINK", sink_kind),
    "REPORT_TZ": os.getenv("REPORT_TZ", "UTC"),
    "BROKER_SAMPLE_RATE": os.getenv("BROKER_SAMPLE_RATE", "0.2")
}
```

**效果**:
- ✅ 跨机复现实验更稳定
- ✅ 便于问题追溯和复现

---

## 文件变更清单

| 文件 | 变更类型 | 说明 |
|------|---------|------|
| `scripts/verify_sink_parity.sh` | 修改 | P0: REPLAY 模式 + 固定输入 |
| `scripts/verify_sink_parity.ps1` | 修改 | P0: REPLAY 模式 + 编码修复 |
| `orchestrator/run.py` | 修改 | P0/P1: 多项优化 |
| `.github/workflows/ci.yml` | 修改 | P0: DoD 断言 + REPLAY 模式 |
| `docs/data_quality.md` | 修改 | P0/P1: DoD 断言 + 护栏枚举 + Broker 分档 |

---

## 验证清单

### P0 项验证

- [x] **REPLAY 模式**: ✅ 双 Sink 对齐脚本使用固定输入
- [x] **PowerShell 编码**: ✅ UTF-8 编码已设置
- [x] **SQLite 健康探针**: ✅ 缺表时明确失败并告警
- [x] **Reporter 时区**: ✅ 支持 REPORT_TZ 环境变量
- [x] **DoD CI 断言**: ✅ CI 自动验证 DoD 约定

### P1 项验证

- [x] **就绪探针尾部读取**: ✅ 只读最后 64KB
- [x] **Reporter 错误计数**: ✅ bad_lines 计数已添加
- [x] **护栏原因枚举**: ✅ 文档已添加枚举/映射表
- [x] **run_manifest 可追溯性**: ✅ config_sha1/features_manifest/env_overrides 已添加

---

## 测试建议

### 快速验证

```powershell
# 1. 验证 REPLAY 模式
$env:V13_REPLAY_MODE = "1"
.\scripts\verify_sink_parity.ps1 -Config ./config/defaults.replay.yaml -Minutes 2

# 2. 验证 Reporter 时区
$env:REPORT_TZ = "Asia/Tokyo"
python -m orchestrator.run `
  --config ./config/defaults.smoke.yaml `
  --enable signal,report `
  --sink jsonl `
  --minutes 1

# 检查报表中的 minute_human 是否使用 Asia/Tokyo 时区

# 3. 验证 SQLite 健康探针
# 创建空数据库，应返回不健康并记录警告

# 4. 验证 run_manifest 可追溯性
# 检查 run_manifest_*.json 是否包含 config_sha1/features_manifest/env_overrides
```

---

## 配置建议

### CI 回归

- **双 Sink 结果对齐**: 使用 REPLAY 模式，固定输入数据窗口
- **DoD 断言**: 自动验证报表 warnings 和 run_manifest 完整性

### 时区配置

- **默认**: `REPORT_TZ=UTC`
- **业务时区**: `REPORT_TZ=Asia/Tokyo` 或 `REPORT_TZ=Asia/Shanghai`

### 输入模式

- **REPLAY 模式**: `V13_REPLAY_MODE=1` + `defaults.replay.yaml`
- **实时模式**: 默认配置

---

**优化完成时间**: 2025-11-07  
**优化状态**: ✅ P0 全部完成，P1 全部完成  
**测试状态**: ⏳ 待验证

