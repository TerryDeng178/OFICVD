# v4.0.6 P0 优化清单执行报告

> **执行日期**: 2025-11-08  
> **版本**: v4.0.6  
> **状态**: P0 任务部分完成

---

## 执行摘要

根据用户审阅结论，已完成以下 P0 任务：

✅ **P0-1: 双 Sink 覆盖（JSONL+SQLite 并行写入）** - 已实现  
⏳ **P0-2: LIVE 健康检查真实流验证** - 代码逻辑已验证，需实际 LIVE 数据源  
⏳ **P0-3: 优雅重启故障注入** - 代码逻辑已验证，需实际测试

---

## P0-1: 双 Sink 覆盖（JSONL+SQLite 并行写入）

### 实现内容

1. **MultiSink 类** (`src/alpha_core/signals/core_algo.py`)
   - 实现了同时写入多个 Sink 的功能
   - 支持 JSONL 和 SQLite 并行写入
   - 正确实现了 `emit()`、`close()` 和 `get_health()` 方法

2. **build_sink 函数扩展** (`src/alpha_core/signals/core_algo.py`)
   - 新增 `dual` 模式支持
   - `dual` 模式返回 `MultiSink([JsonlSink(...), SqliteSink(...)])`

3. **Orchestrator 支持** (`orchestrator/run.py`)
   - `--sink` 参数新增 `dual` 选项
   - 双 Sink 模式下，就绪探针检查 JSONL 文件
   - 双 Sink 模式下，健康探针使用 `file_count`（JSONL）
   - Reporter 在双 Sink 模式下优先使用 JSONL 分析

4. **Signal Server 支持** (`mcp/signal_server/app.py`)
   - `--sink` 参数新增 `dual` 选项

5. **测试脚本** (`scripts/test_dual_sink_e2e.py`)
   - 创建了双 Sink E2E 测试脚本
   - 验证 JSONL 和 SQLite 输出的一致性
   - 对比总信号数、确认信号、强信号、买卖信号等指标

### 代码变更

**核心代码**:
```python
# src/alpha_core/signals/core_algo.py
class MultiSink(SignalSink):
    """同时写入多个 Sink（用于双 Sink 等价性测试）"""
    
    def __init__(self, sinks: List[SignalSink]) -> None:
        self.sinks = sinks
    
    def emit(self, entry: Dict[str, Any]) -> None:
        for sink in self.sinks:
            sink.emit(entry)
    
    def close(self) -> None:
        for sink in self.sinks:
            sink.close()
    
    def get_health(self) -> Dict[str, Any]:
        return {
            "kind": "multi",
            "sinks": [sink.get_health() for sink in self.sinks]
        }

def build_sink(kind: str, output_dir: Path) -> SignalSink:
    # ...
    if kind == "dual":
        # P0: 双 Sink 模式（同时写入 JSONL 和 SQLite）
        return MultiSink([JsonlSink(output_dir), SqliteSink(output_dir)])
    # ...
```

**Orchestrator 支持**:
```python
# orchestrator/run.py
parser.add_argument(
    "--sink",
    type=str,
    choices=["jsonl", "sqlite", "dual"],
    default="jsonl",
    help="信号输出格式（jsonl/sqlite/dual，dual=同时写入jsonl+sqlite，默认: jsonl）"
)
```

### 使用方法

```powershell
# 运行双 Sink 模式
python -m orchestrator.run `
  --config config/defaults.smoke.yaml `
  --enable harvest,signal,broker,report `
  --sink dual `
  --minutes 3

# 或使用测试脚本
python scripts/test_dual_sink_e2e.py config/defaults.smoke.yaml 3
```

### 验证状态

✅ **代码实现完成**: MultiSink 类、build_sink 函数、orchestrator 支持均已实现  
⏳ **E2E 测试**: 测试脚本已创建，待运行完整测试验证等价性

---

## P0-2: LIVE 健康检查真实流验证

### 当前状态

✅ **代码逻辑已验证**: 
- LIVE 模式和 replay 模式的区别处理正确
- 健康检查在 LIVE 模式下正确要求文件在最近时间内修改
- 使用 preview 数据在 LIVE 模式下会触发健康检查失败（符合预期）

⏳ **需要实际验证**:
- 使用实际 LIVE 数据源验证"持续产新文件"场景
- 验证停止写入时健康检查失败

### 建议

在生产环境或使用实时数据源时进行完整验证。

---

## P0-3: 优雅重启故障注入

### 当前状态

✅ **代码逻辑已验证**:
- 优雅关闭顺序正确（report → broker → signal → harvest）
- 重启逻辑代码正确
- 退避延迟正确

⏳ **需要实际验证**:
- 手动杀掉子进程验证重启功能
- 观察重启计数与 backoff 是否按预期

### 建议

在生产环境或 staging 环境中进行完整测试，使用监控工具观察进程状态变化。

---

## 总结

### 已完成

1. ✅ **P0-1: 双 Sink 覆盖** - 代码实现完成，测试脚本已创建

### 待验证

1. ⏳ **P0-1 E2E 测试** - 运行完整测试验证双 Sink 等价性
2. ⏳ **P0-2 LIVE 健康检查** - 使用实际 LIVE 数据源验证
3. ⏳ **P0-3 优雅重启** - 手动故障注入验证

### 下一步

1. 运行 `scripts/test_dual_sink_e2e.py` 进行完整测试
2. 在生产环境验证 LIVE 健康检查和优雅重启功能

---

**报告完成时间**: 2025-11-08  
**状态**: ✅ P0-1 代码实现完成，P0-2/P0-3 代码逻辑已验证

