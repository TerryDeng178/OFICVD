# F2/F3/F4功能实现报告

## 实现时间
2025-11-11

## 概述

已完成F2、F3、F4三个功能的基础实现，支持F系列实验的运行。

---

## F2: w_ofi + w_cvd = 1.0约束

### 实现位置
`src/alpha_core/report/optimizer.py` - `generate_trials`方法

### 实现逻辑
- 在生成trial配置时，检查`components.fusion.w_ofi`和`components.fusion.w_cvd`
- 如果`w_ofi + w_cvd != 1.0`，自动调整`w_cvd`使其和为1.0
- 同时更新trial_config和trial_params

### 代码片段
```python
# F2修复: 确保w_ofi + w_cvd = 1.0约束
if "components.fusion.w_ofi" in trial_params and "components.fusion.w_cvd" in trial_params:
    w_ofi = trial_params["components.fusion.w_ofi"]
    w_cvd = trial_params["components.fusion.w_cvd"]
    # 如果w_ofi + w_cvd != 1.0，调整w_cvd使其和为1.0
    if abs(w_ofi + w_cvd - 1.0) > 1e-6:
        w_cvd_adjusted = 1.0 - w_ofi
        self._set_nested_value(trial_config, "components.fusion.w_cvd", w_cvd_adjusted)
        trial_params["components.fusion.w_cvd"] = w_cvd_adjusted
```

### 支持的方法
- ✅ Grid搜索
- ✅ Random搜索

---

## F3: cooldown_after_exit_sec支持

### 实现位置
`src/alpha_core/signals/core_algo.py`

### 实现逻辑
1. **初始化**：从`strategy.cooldown_after_exit_sec`配置中读取冷静期时长
2. **跟踪退出时间**：维护`_last_exit_ts_per_symbol`字典，记录每个symbol的最后退出时间
3. **信号生成时检查**：在`process_feature_row`中检查是否在冷静期内
4. **记录退出**：提供`record_exit`方法供外部调用

### 代码片段

#### 初始化
```python
# F3修复: 退出后冷静期跟踪
strategy_cfg = self.config.get("strategy", {})
self.cooldown_after_exit_sec = int(strategy_cfg.get("cooldown_after_exit_sec", 0))
self._last_exit_ts_per_symbol: Dict[str, int] = {}  # symbol -> last_exit_ts_ms
```

#### 信号生成时检查
```python
# F3修复: 退出后冷静期检查（需要在ReplayFeeder中调用record_exit来更新）
if self.cooldown_after_exit_sec > 0:
    last_exit_ts = self._last_exit_ts_per_symbol.get(symbol)
    if last_exit_ts is not None:
        elapsed_sec = (ts_ms - last_exit_ts) / 1000.0
        if elapsed_sec < self.cooldown_after_exit_sec:
            # 仍在冷静期内，阻止信号
            gating_reasons.append(f"cooldown_after_exit({elapsed_sec:.1f}s<{self.cooldown_after_exit_sec}s)")
            self._stats.suppressed += 1
```

#### 记录退出方法
```python
def record_exit(self, symbol: str, ts_ms: int) -> None:
    """F3修复: 记录退出时间，用于退出后冷静期"""
    if self.cooldown_after_exit_sec > 0:
        self._last_exit_ts_per_symbol[symbol] = ts_ms
        logger.debug(f"[CoreAlgorithm] F3: 记录退出时间 {symbol} @ {ts_ms}")
```

### 待完成工作
⚠️ **需要在TradeSimulator中调用`record_exit`**：
- 在`TradeSimulator._exit_position`方法中，退出持仓后调用`CoreAlgorithm.record_exit`
- 需要将`CoreAlgorithm`实例传递给`TradeSimulator`，或在`ReplayFeeder`中桥接

---

## F4: scenario_overrides支持

### 实现位置
`src/alpha_core/signals/core_algo.py` - `process_feature_row`方法

### 实现逻辑
1. **读取场景信息**：从feature row中获取`scenario_2x2`（A_H/Q_H/A_L/Q_L）
2. **应用场景化覆写**：根据`scenario_overrides`配置应用偏移
3. **影响参数**：
   - `weak_signal_threshold`：弱信号阈值
   - `consistency_min`：一致性最小值
   - `min_consecutive`：最小连击数

### 代码片段

#### 场景化覆写逻辑
```python
# F4修复: 场景化阈值覆写
scenario_2x2 = row.get("scenario_2x2")  # A_H, Q_H, A_L, Q_L
effective_weak_signal_threshold = self.config["weak_signal_threshold"]
effective_consistency_min = self.config["consistency_min"]
effective_min_consecutive = self.min_consecutive_same_dir

scenario_overrides = self.config.get("scenario_overrides", {})
if scenario_overrides and scenario_2x2:
    scenario_override = scenario_overrides.get(scenario_2x2, {})
    if scenario_override:
        # 应用场景化偏移
        weak_offset = scenario_override.get("weak_signal_threshold_offset", 0.0)
        consistency_offset = scenario_override.get("consistency_min_offset", 0.0)
        min_consecutive_offset = scenario_override.get("min_consecutive_offset", 0)
        
        effective_weak_signal_threshold = self.config["weak_signal_threshold"] + weak_offset
        effective_consistency_min = self.config["consistency_min"] + consistency_offset
        effective_min_consecutive = self.min_consecutive_same_dir + min_consecutive_offset
```

#### 使用覆写后的参数
```python
# 使用effective_weak_signal_threshold
if abs(score) < effective_weak_signal_threshold and not warmup:
    gating_reasons.append("weak_signal")

# 使用effective_consistency_min
if consistency < effective_consistency_min:
    gating_reasons.append("low_consistency")

# 使用effective_min_consecutive
if confirm and effective_min_consecutive > 1:
    streak = self._get_dir_streak(symbol, score)
    if streak < effective_min_consecutive:
        confirm = False
        gating_reasons.append(f"reverse_cooldown_insufficient_ticks({streak}<{effective_min_consecutive})")
```

### 配置示例
```yaml
signal:
  scenario_overrides:
    A_H:
      weak_signal_threshold_offset: 0.02
      consistency_min_offset: 0.02
      min_consecutive_offset: 1
    Q_H:
      weak_signal_threshold_offset: 0.02
      consistency_min_offset: 0.02
      min_consecutive_offset: 1
```

---

## 测试建议

### F2测试
1. 创建包含`w_ofi`和`w_cvd`的搜索空间
2. 验证生成的trial配置中`w_ofi + w_cvd = 1.0`

### F3测试
1. 设置`strategy.cooldown_after_exit_sec = 60`
2. 在TradeSimulator中调用`record_exit`
3. 验证退出后60秒内不会生成新信号

### F4测试
1. 设置`scenario_overrides`配置
2. 验证A_H/Q_H场景下阈值是否正确应用偏移
3. 验证A_L/Q_L场景使用全局基线

---

## 待完成工作

### F3完整实现
- [ ] 在`TradeSimulator._exit_position`中调用`CoreAlgorithm.record_exit`
- [ ] 确保`CoreAlgorithm`实例可访问（通过ReplayFeeder桥接或直接传递）

### 文档更新
- [ ] 更新F系列实验执行说明，说明F3的完整使用方式
- [ ] 添加F3的配置示例

---

## 参考文件

- `src/alpha_core/report/optimizer.py` - F2实现
- `src/alpha_core/signals/core_algo.py` - F3/F4实现
- `runtime/optimizer/group_f*.yaml` - F系列配置文件
- `tasks/TASK-09/search_space_f*.json` - F系列搜索空间

