下面这份就是你要的**迁移任务卡（Markdown版）**，已经把“怎么把策略层从回测组件抽出去”和“如何防止以后策略逻辑又回流到回测壳”都写进去了

---

# TASK-STRATEGY-LAYER-MIGRATION

策略层抽离与回测边界收紧

## 1. 背景与问题

当前 `app.py`（回测 APP）中包含了完整的**策略层逻辑**，主要集中在：

* 常量：`SOFT_GATING` / `HARD_ALWAYS_BLOCK`
* 函数：`is_tradeable(signal, gating_mode)`
* 类：`StrategyEmulator`

  * `should_trade()`：综合 confirm、gating、quality_mode 做“要不要下单”决策
  * `decide_side()`：根据 `signal_type` / `side_hint` / `score` 决策 BUY / SELL

这些逻辑本质上是**环境无关的“策略决策层”**，应该在：

* 回测
* 测试网
* 实盘

三种环境下统一复用。但目前只存在于回测 APP 中：

* 将来测试网 / 实盘容易再写一套类似逻辑 → 策略漂移、行为不一致；
* 回测组件“过肥”，既做环境又做策略 → 无法保持“确认漏斗 → 交易质量 → PnL”在各环境的一致性。

本任务的目标是：
**把“策略层”抽到 `alpha_core.strategy` 公共模块中，回测 APP 只做“环境壳”，并建立防线避免将来策略代码再渗回回测组件。**

---

## 2. 目标与非目标

### 2.1 任务目标（Goals）

1. 将以下策略层组件从 `app.py` 抽离到公共模块：

   * `SOFT_GATING`
   * `HARD_ALWAYS_BLOCK`
   * `is_tradeable(signal, gating_mode)`
   * `StrategyEmulator`（含 `decide_side` / `should_trade`）
2. 回测 APP 改为**只调用公共策略模块**，行为完全不变：

   * 相同输入信号 → 相同的 `should_trade` / `decide_side` 结果
3. 在代码结构 / 测试 / CI 规范上建立**边界防线**：

   * 回测组件不再出现新的策略决策逻辑（gating/quality/side 判定）；
   * 策略决策逻辑只能出现在 `alpha_core.strategy` 模块中。

### 2.2 非目标（Non-Goals）

* 不调整 fusion / consistency / confirm 的计算公式（另有 confirm pipeline 调优任务负责）。
* 不改 PnL 计算逻辑，不引入新的回测规则。
* 不引入复杂 ML / 新特征，仅做架构边界重构与行为等价。

---

## 3. 设计原则（架构边界）

1. **策略层（Strategy Layer）**

   * 负责：

     * 判断是否可以交易（confirm + gating + quality）
     * 决定交易方向（BUY / SELL）
   * 承载模块：`alpha_core.strategy.*`
   * 输入：标准化的 `signal` dict（含 score/confirm/gating_reasons/quality_tier 等）
   * 输出：

     * `should_trade(signal) -> (bool, reason_str | None)`
     * `decide_side(signal) -> "BUY" | "SELL" | None`

2. **环境壳（Environment / Harness）**

   * 回测 APP / 测试网 Runner / 实盘 Orchestrator：

     * 负责：数据源、价格/盘口、撮合、订单生命周期、PnL 聚合、落盘等
   * 禁止：

     * 在环境壳中新增任何“策略决策逻辑”，例如：

       * 直接判断 `gating_reasons` 决定是否下单
       * 直接根据 `score` 正负决定 side
       * 在壳里再套一层“质量过滤”

3. **统一决策链**

```
signal (from CoreAlgorithm)
    ↓
StrategyEmulator.should_trade(signal)    # 公共策略层
    ↓
StrategyEmulator.decide_side(signal)     # 公共策略层
    ↓
IExecutor / BrokerSimulator              # 各环境壳
```

---

## 4. 实施步骤（分阶段）

### Phase A：创建公共策略模块（alpha_core.strategy）

**A1. 创建新模块文件**

建议目录：

```text
src/alpha_core/strategy/__init__.py
src/alpha_core/strategy/policy.py
```

在 `policy.py` 中：

* 定义原来在 `app.py` 顶部的常量：

```python
SOFT_GATING = {"weak_signal", "low_consistency"}

HARD_ALWAYS_BLOCK = {
    "fallback",
    "price_cache_failed",
    "no_price",
    "spread_bps_exceeded",
    "lag_sec_exceeded",
    "kill_switch",
    "guarded",
    # 其他已有硬护栏标签
}
```

* 迁移 `is_tradeable(signal, gating_mode)` 函数逻辑（保持行为不变）：

  * 输入：`signal: dict`, `gating_mode: str`
  * 输出：`(bool, Optional[str])`
  * 内部依然使用 `SOFT_GATING` / `HARD_ALWAYS_BLOCK`

* 迁移 `StrategyEmulator` 类：

  * 构造参数保持不变：

    * `config`
    * `gating_mode`
    * `legacy_backtest_mode`
    * `quality_mode`
  * 方法：

    * `decide_side(self, signal) -> Optional[str>`
    * `should_trade(self, signal) -> tuple[bool, Optional[str]]`
  * 仅做“剪切+少量路径调整”，不改实质逻辑

**A2. 统一配置读取细节（小范围清理）**

趁迁移顺手统一一个配置访问差异（可选但推荐）：

* 将 `min_abs_score_for_side` 的读取统一为：

```python
min_abs_score = (
    self.config
    .get("signal", {})
    .get("min_abs_score_for_side", 0.1)
)
```

确保 legacy 模式及正常模式读取方式一致。

**A3. 补充单元测试（新文件 tests）**

创建新测试文件：

```text
tests/test_strategy_policy.py
```

覆盖核心路径：

* `is_tradeable`：

  * 不同 `gating_mode`（strict / ignore_soft / ignore_all）
  * 不同 `gating_reasons` 组合（硬护栏、软护栏、多标签）
  * `confirm=True/False` 场景
* `StrategyEmulator`：

  * `legacy_backtest_mode=True/False`
  * 各种 `quality_mode`：conservative / balanced / aggressive / all
  * 不同 `signal_type` / `side_hint` / `score` 的组合，验证 `decide_side` 输出

> 目标：**策略层在单元测试维度独立可验证，与回测壳解耦。**

---

### Phase B：回测 APP 改用公共策略模块（行为等价）

**B1. 调整 app.py 的导入**

在 `app.py` 中：

* 删除本地定义的：

  * `SOFT_GATING`
  * `HARD_ALWAYS_BLOCK`
  * `is_tradeable`
  * `StrategyEmulator`
* 改为：

```python
from alpha_core.strategy.policy import (
    SOFT_GATING,
    HARD_ALWAYS_BLOCK,
    is_tradeable,
    StrategyEmulator,
)
```

**B2. 行为等价回归测试（golden sample）**

编写一个小脚本 / 测试用例，步骤：

1. 构造一批固定的 fake signals（可以从历史 JSONL 截取 20–50 行典型样本）。
2. **迁移前**（可以用 git 旧版本或本地备份）：

   * 用旧 `app.py` 中的 `StrategyEmulator` 路径，记录：

     * `should_trade` 返回值与 reason
     * `decide_side` 返回值
3. **迁移后**：

   * 用新模块里的 `StrategyEmulator` 路径，跑完全相同的 signals。
4. 写一个测试比对：

   * 迁移前后 `should_trade` / `decide_side` 的输出必须 **逐条一致**。

> DoD：**策略层迁移后，策略决策行为对同一输入完全不变。**

---

### Phase C：建立“防止策略层再次进回测”的长期防线

重点是**制度 + 工具 + 测试三层防线**，防止以后有人在回测 APP/Runner 里又写一套 gating/quality/side 逻辑。

#### C1. 架构约束文档（README / 设计文档）

在项目文档（例如 `README_architecture.md` 或 `TASK_INDEX.md` 附录）中新增一段：

> **策略层边界约束：**
>
> * 所有与以下内容相关的逻辑：
>
>   * `SOFT_GATING` / `HARD_ALWAYS_BLOCK`
>   * `confirm` → `should_trade` 决策
>   * 质量档位过滤（`quality_tier` / `quality_flags` / `quality_mode`）
>   * 决策方向（BUY / SELL）
> * **必须实现于 `alpha_core.strategy` 模块中**。
> * 回测 APP / Runner / Orchestrator 仅通过 `StrategyEmulator` 或统一接口调用，不允许自行解析 `gating_reasons` / `quality_flags` 再做逻辑判断。

#### C2. Code Review Checklist

在 PR 模板或内部 checklist 中增加“策略边界检查”条目：

* [ ] 本 PR 没有在 `app.py` / `scripts/*` / `backtest_*` 中新增任何：

  * 直接访问 `signal["gating_reasons"]` 或 `signal["quality_tier"]` 决策是否交易；
  * 直接根据 `score` / `side_hint` 组合做方向判断；
  * 重新实现 `SOFT_GATING` / `HARD_ALWAYS_BLOCK` 等逻辑。
* [ ] 所有“是否交易 / 方向决策”的逻辑都通过 `StrategyEmulator` 或 `alpha_core.strategy` 统一入口实现。

#### C3. 简单自动化检测（Lint/CI）

可以加一个非常轻量级的“策略泄漏检测脚本”（可选但很实用）：

* 写一个小 Python 脚本（例如 `scripts/check_strategy_leakage.py`）：

  * 扫描以下文件：

    * `app.py`
    * `scripts/backtest_*.py`
    * 其他回测 harness 相关文件
  * 检测是否包含以下“危险模式”：

    * 字符串 `"gating_reasons"` 出现在 `if` 条件附近
    * 正则匹配：`if .*score` / `if .*side_hint` / `if .*quality_tier`
    * 重新定义 `SOFT_GATING` / `HARD_ALWAYS_BLOCK` / `StrategyEmulator` 字样

* 在 CI 中增加步骤：

  * `python scripts/check_strategy_leakage.py`
  * 如检测到“嫌疑代码”，直接 fail，并输出提示：

    > “检测到策略决策逻辑出现在回测组件，请迁移到 alpha_core.strategy 模块。”

这类 check 不需要 100% 严格精准，只要能挡住 80–90% 的“无意识回流”，其余由 review 把关。

---

## 5. Definition of Done（完成标准）

本任务在满足以下条件时视为完成：

1. **策略模块抽离完成**

   * `alpha_core.strategy.policy` 中包含：

     * `SOFT_GATING` / `HARD_ALWAYS_BLOCK`
     * `is_tradeable`
     * `StrategyEmulator`
   * `app.py` 不再定义上述常量/函数/类，只是 import 使用。

2. **行为等价**

   * `tests/test_strategy_policy.py` 通过，覆盖 gating/quality/side 三大路径；
   * golden sample 对比通过：迁移前后对同一批 signals，`should_trade` / `decide_side` 输出完全一致。

3. **回测边界收紧**

   * 回测 APP / Backtest Harness 不再直接解析 gating/quality 来做决策，只通过 `StrategyEmulator`；
   * README / 架构文档中明确记录“策略层只能在 `alpha_core.strategy` 实现”的边界规则；
   * PR 模板中包含策略边界检查项；
   * （可选但加分）CI 中启用 `check_strategy_leakage.py` 自动检测。

4. **不引入新逻辑**

   * confirm 计算、PnL 计算逻辑与迁移前完全一致；
   * 本任务不改变任何回测数值结果（除非修正了明显 bug，并在 PR 说明中标注）。

---
 